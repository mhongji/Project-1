---
title: "Project 1"
author: 
  - Hongjing Mao
  - Yuhan Hu
date: "2025-06-14"
format: pdf
editor: visual
---

## Step 1: Data preprocessing

```{r}
library(tidyverse)

url <- "https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv"

edu01a <- read_csv(url, show_col_types = FALSE) %>% 
  select(
    area_name = Area_name,   # rename
    STCOU,
    ends_with("D")           # keep every column ending in “D”
  )

head(edu01a, 5)              # display first 5 rows
```

## Step 2: wide string to long string

```{r}
library(tidyr)

edu01a_long <- edu01a %>% 
  pivot_longer(
    cols  = -c(area_name, STCOU),   # every “D” column
    names_to  = "raw_var",          # original census column name
    values_to = "enrollment",       # numeric value
    values_drop_na = TRUE           # drop empty cells, if any
  )

head(edu01a_long, 5)                # verify first 5 rows
```

## Step 3: Parse variable name string

```{r}
long_updated <- edu01a_long %>% 
  mutate(
    # last two digits before the "D"
    yr_two      = substr(raw_var, nchar(raw_var) - 2, nchar(raw_var) - 1),  # e.g. "97" or "02"
    year        = as.integer(
                   if_else(as.integer(yr_two) <= 30,  # 00-30 → 2000-2030
                           paste0("20", yr_two),
                           paste0("19", yr_two))      # 31-99 → 1931-1999
                 ),
    measurement = substr(raw_var, 1, 7)               # first 3 chars + next 4 digits
  ) %>% 
  select(-yr_two)                                     # helper no longer needed

head(long_updated, 5)
```

## Step 4: Separate county vs non-county data & add classes

```{r}
library(dplyr)
library(stringr)

# rows whose Area_name ends “, XX” → county measurements
county_idx <- grep(", \\w\\w$", long_updated$area_name)

county_tibble <- long_updated[county_idx, ] %>% 
  mutate(area_name = str_trim(area_name))          # tidy up trailing spaces
class(county_tibble) <- c("county", class(county_tibble))

state_tibble  <- long_updated[-county_idx, ]
class(state_tibble)  <- c("state",  class(state_tibble))

# quick check: first 10 rows of each
head(county_tibble, 10)
head(state_tibble,  10)
```

## Step 5: Create new variable

```{r}
library(stringr)

county_tibble <- county_tibble %>% 
  mutate(
    state = str_sub(area_name, -2, -1)   # grab the “DD” after the comma
  )
```

## Step 6: Add “division” to non-county (state) rows

```{r}
# ---- STEP 6 · rebuild & test division mapping ----------------------------
library(dplyr)
library(rvest)
library(stringr)
library(tidyr)
library(purrr)

# 1️⃣ Scrape all wikitables with %>%
wiki_url <- "https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States"
tbls <- wiki_url %>%
  read_html() %>%
  html_elements("table.wikitable") %>%
  map(html_table, fill = TRUE)

# 2️⃣ Pick the one with a “Division” column
div_raw <- tbls %>%
  keep(~ any(str_detect(names(.x), regex("Division", ignore_case = TRUE)))) %>%
  .[[1]]

# 3️⃣ Tidy into a state‐abbrev → division lookup
division_tbl <- div_raw %>%
  select(division = Division, states = 3) %>%     # col 3 lists states
  mutate(states = str_remove_all(states, "\\[[^]]*\\]")) %>%  
  separate_rows(states, sep = "[,\\n]") %>%  
  mutate(states = str_trim(states)) %>%  
  filter(states != "") %>%  
  mutate(state = state.abb[match(states, state.name)]) %>%  
  filter(!is.na(state)) %>%  
  distinct(state, division)

# 4️⃣ Re‐build your non‐county tibble (if needed)
county_idx   <- grep(", \\w\\w$", long_updated$area_name)
state_tibble <- long_updated[-county_idx, ]

# 5️⃣ Extract USPS code from full state name & join
state_tibble <- state_tibble %>%
  mutate(
    state = if_else(area_name %in% state.name,
                    state.abb[match(area_name, state.name)],
                    NA_character_)
  ) %>%
  left_join(division_tbl, by = "state") %>%
  mutate(
    division = if_else(is.na(division), "ERROR", division)
  )

# 6️⃣ CHECK the results
all_errors <- all(state_tibble$division == "ERROR")
cat("All divisions are ERROR? ", all_errors, "\n\n")

print(table(state_tibble$division))

# 7️⃣ If it’s still all ERROR, inspect which names failed to map:
if (all_errors) {
  cat("\nUnmatched area_name values:\n")
  print(state_tibble %>% 
          distinct(area_name) %>% 
          filter(!area_name %in% state.name))
}

```

```         
```

### Requirements 

```{r}
library(tidyverse)
library(rvest)
library(purrr)
library(tidyr)
library(stringr)
```

### Step 1&2

```{# ─── 1) read_and_pivot(): STEPS 1 & 2 ─────────────────────────────────────}
# Reads a CSV from `url`, selects Area_name, STCOU, cols ending in “D”,
# then pivots to long format. `value_var` names the value column.
read_and_pivot <- function(url, value_var = "enrollment") {
  read_csv(url, show_col_types = FALSE) %>%
    select(
      area_name = Area_name,
      STCOU,
      ends_with("D")
    ) %>%
    pivot_longer(
      cols           = -c(area_name, STCOU),
      names_to       = "raw_var",
      values_to      = value_var,
      values_drop_na = TRUE
    )
}
```

### Step 3 

```{r}
# ─── 2) parse_raw(): STEP 3 ───────────────────────────────────────────────
# Extracts `year` and `measurement` from the `raw_var` column.
parse_raw <- function(df) {
  df %>%
    mutate(
      yr_code     = str_sub(raw_var, -3, -2),
      year        = as.integer(if_else(
                       as.integer(yr_code) <= 30,
                       paste0("20", yr_code),
                       paste0("19", yr_code)
                     )),
      measurement = str_sub(raw_var, 1, 7)
    ) %>%
    select(-yr_code)
}

```

```{r}
# ─── 3) add_state_county(): STEP 5 ────────────────────────────────────────
# For county-level rows, adds `state` = last two letters of area_name.
add_state_county <- function(county_df) {
  county_df %>%
    mutate(state = str_sub(area_name, -2, -1))
}
```

```{r}
# ─── 4) add_division_state(): STEP 6 ─────────────────────────────────────
# Scrapes the Census “Regions & Divisions” table from Wikipedia,
# builds a state→division lookup, then adds `division` (or "ERROR").
add_division_state <- function(state_df) {
  # build lookup
  wiki_url <- "https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States"
  division_tbl <- wiki_url %>%
    read_html() %>%
    html_elements("table.wikitable") %>%
    map(html_table, fill = TRUE) %>%
    keep(~ any(str_detect(names(.x), regex("Division", ignore_case = TRUE)))) %>%
    .[[1]] %>%
    select(division = Division, states = 3) %>%
    mutate(states = str_remove_all(states, "\\[[^]]*\\]")) %>%
    separate_rows(states, sep = "[,\\n]") %>%
    mutate(states = str_trim(states)) %>%
    filter(states != "") %>%
    mutate(state = state.abb[match(states, state.name)]) %>%
    filter(!is.na(state)) %>%
    distinct(state, division)

  # annotate your data
  state_df %>%
    mutate(
      state = if_else(area_name %in% state.name,
                      state.abb[match(area_name, state.name)],
                      NA_character_)
    ) %>%
    left_join(division_tbl, by = "state") %>%
    mutate(division = if_else(is.na(division), "ERROR", division))
}

```

```{r}
# ─── 5) make_tibbles(): STEP 4 + calls 5 & 6 ──────────────────────────────
# Splits the parsed-long data into county vs non-county, then applies
# add_state_county() and add_division_state() to each side.
make_tibbles <- function(parsed_df) {
  idx       <- grep(", \\w\\w$", parsed_df$area_name)
  county_df <- parsed_df[idx, ] %>% add_state_county()
  state_df  <- parsed_df[-idx, ] %>% add_division_state()
  list(county = county_df, state = state_df)
}

```
